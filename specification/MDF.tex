\documentclass[landscape,a4paper]{article} %12pt
\usepackage{multicol}
\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[landscape,margin=1.3in]{geometry}
\usepackage{tabularx}
\usepackage{rotating}
\usepackage{listings}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{hyperref}

\clubpenalty10000
\widowpenalty10000
\displaywidowpenalty=10000

\hypersetup
{
    pdfauthor={Tobias Knopp, Thilo Viereck, and Martin M\"oddel},
    pdfsubject={Magnetic Particle Imaging Data Storage Format},
    pdftitle={MDF: Magnetic Particle Imaging Data Format},
    pdfkeywords={MPI, MDF, HDF5},
    pdfproducer={Section for Biomedical Imaging Hamburg University of Technology, Section for Biomedical Imaging University Medical Center Hamburg-Eppendorf},
    pdfcreator={Section for Biomedical Imaging Hamburg University of Technology, Section for Biomedical Imaging University Medical Center Hamburg-Eppendorf}
}

\lstdefinelanguage{MDF}%
  {morekeywords={%
    Bool,Int64,Float64,Number,String%
      },%
   sensitive=true,%
}[keywords,comments,strings]%

\lstset{%
    language         = MDF,
    basicstyle       = \ttfamily,
    numbers=left, 
    columns=fullflexible,
    numberstyle=\small\ttfamily\color{Gray},
    stepnumber=1,              
    numbersep=10pt, 
    numberfirstline=true, 
    numberblanklines=true, 
    tabsize=4,
    lineskip=-1.5pt,
    extendedchars=true,
    breaklines=true,
    keywordstyle     = \bfseries\color{blue},
    stringstyle      = \color{magenta},
    commentstyle     = \color{ForestGreen},
    showstringspaces = false,
    showtabs=false,
    upquote=false,
    texcl=true % interpet comments as LaTeX
}

\newcommand{\inl}[1]{\lstinline[columns=fixed]{#1}}
\newcommand{\inltab}[1]{{\ttfamily\bfseries\color{blue}#1}}
\newcommand{\inlvar}[1]{{\ttfamily#1}}

\begin{document}

\title{MDF: Magnetic Particle Imaging Data Format}
\newcommand{\version}{2.0.0-pre}

\author{
T.~Knopp$^{1,2}$, T.~Viereck$^3$, G.~Bringout$^4$, M.~Ahlborg$^5$, A.~von~Gladi\ss$^5$, C.~Kaethner$^5$, P.~Vogel$^6$, J.~Rahmer$^7$, M.~M\"oddel$^{1,2}$ \\ \\
$^1$Section for Biomedical Imaging, University Medical Center Hamburg-Eppendorf, Germany\\
$^2$Institute for Biomedical Imaging, Hamburg University of Technology, Germany\\
$^3$Institute of Electrical Measurement and Fundamental Electrical Engineering, TU Braunschweig, Germany\\
$^4$Physikalisch-Technische Bundesanstalt, Berlin, Germany\\
$^5$Institute of Medical Engineering, University of  Lübeck, Germany\\
$^6$Department of Experimental Physics 5 (Biophysics), University of Würzburg, Germany\\
$^7$Philips GmbH Innovative Technologies, Research Laboratories, Hamburg, Germany
}

\maketitle
\begin{center}
Version \textbf{\version}
\end{center}

\begin{abstract}
Magnetic particle imaging (MPI) is a tomographic method to determine the spatial distribution of magnetic nanoparticles. In this document a file format for the standardized storage of MPI data is introduced. The aim of the Magnetic Particle Imaging Data Format (MDF) is to provide a coherent way of exchanging MPI data acquired with different MPI scanners worldwide. The focus of the file format is on sequence parameters, raw measurement data, calibration data, and reconstruction data. The format is based on the hierarchical document format (HDF) in version 5 (HDF5).
\end{abstract}


\begin{multicols}{2}[\section{Introduction} \label{Sec:Introduction}]

	The purpose of this document is to introduce a file format for exchanging Magnetic Particle Imaging (MPI) data. The Magnetic Particle Imaging Data Format (MDF) is based on the hierarchical document format (HDF) in version 5 (HDF5) \cite{hdf5}. HDF5 allows to store multiple datasets within a single file and is thus very flexible to use. To allow the exchange of MPI data, one has to specify a naming scheme within HDF5 files which is the purpose of this document. In order to create and access HDF5 data, an Open Source C library is available. For most programming languages bindings to this library exist. Matlab supports HDF5 by the functions \inl{h5read} and \inl{h5write}. For Python the \inl{h5py} package exists. The Julia programming language provides access to HDF5 files via the \inl{HDF5} package. For languages based on the .NET framework the \inl{HDF5DotNet} library is available.

In this initial version of the file format the focus is on sequence parameters, raw measurement data, calibration data, and reconstruction data. The format can store three different dataset types
\begin{enumerate}
\setlength{\itemsep}{0pt}
\item Measurement data
\item System calibration data
\item Reconstruction data
\end{enumerate}
It is possible to combine measurement data and reconstruction data into a single file. However, calibration data has to be stored in an independent HDF5 file.

\subsection{Datatypes}

For most parameters a fixed datatype is used, i.e. the drive-field amplitudes are stored as \inl{H5T_NATIVE_DOUBLE} values. For our convinience we refer to the HDF5 datatypes \inl{H5T_STRING}, \inl{H5T_NATIVE_DOUBLE} and \inl{H5T_NATIVE_INT64} as \inltab{String}, \inltab{Float64} and \inltab{Int64}. The datatype of the measurement data and the calibration data offers more freedom and is denoted by \inltab{Number}, which can be any of the following HDF5 data types: \inl{H5T_NATIVE_FLOAT}, \inl{H5T_NATIVE_DOUBLE}, \inl{H5T_NATIVE_INT8}, \inl{H5T_NATIVE_INT16}, \inl{H5T_NATIVE_INT32}, and \inl{H5T_NATIVE_INT64}.

MPI parameters are stored as regular \textit{HDF5 datasets}. \textit{HDF5 attributes} are not used in the current specification of the MDF.

Since storing complex data in HDF5 is not standardized, we extend the dimensionality of an existing array and store the real and imaginary part in the last dimension with size 2 (index 0 = real part, index 1 = imaginary part). In this way the real and imaginary part of a complex datum is stored sequentially on disk. When loading the data it is possible to cast it to a complex array in most programming languages.

\subsection{Units}

Physical quantities are given in SI units with one exception. The field strength is reported in T$\mu_0^{-1}$ = 4 $\pi$ Am$^{-1}\mu_0^{-1}$. This convention has been proposed in the first MPI publication and since that time consistently used in most MPI related publications. The aim of this convention is to report the numbers on a Tesla scale, which most readers with a background in MRI are familiar with, but, on the other hand still use the correct unit for the magnetic field strength.


\subsection{Sanity Check}

In order to check if a generated MDF file is valid, we provide a sanity check script that can be found in the gitub repository:\\
\hspace*{1cm}\url{https://github.com/MagneticParticleImaging/MDF}\\
The code is written in the Julia programming language \cite{Bezanson2012,Bezanson2014,Bezanson2014a}, which has to be downloaded from: \\
\hspace*{1cm} \url{http://julialang.org}.\\
More detailed instructions can be found in the \texttt{README} of the repository.

\subsection{Contact}

If you find mistakes in this document or the specified file format or if you want to discuss extensions to this specification, please open an issue on GitHub:\\
\hspace*{1cm}\url{https://github.com/MagneticParticleImaging/MDF}\\
As the file format is versionized it will be possible to extend it for future needs of MPI. The current version discussed in this document is version \version.

\subsection{arXiv}
As of version 1.0.1 the most recent release of these specifications can also be also found on the arXiv:\\
\hspace*{1cm}\url{http://arxiv.org/abs/1602.06072}\\
If you use MDF please cite us using the arXiv reference, which is also available for download as \texttt{MDF.bib} from GitHub.

\end{multicols}

\section{Data (group: \inl{/})}
 \setlength\extrarowheight{5pt}

\begin{multicols}{2}

\paragraph{Remarks:} Within the root group metadata about the file itself is stored. Within several subgroups, metadata about the experimental setting, the MPI tracer, and the MPI scanner are stored. The actual data is stored in dedicated groups on measurement data, calibration data, and/or reconstruction data.

\end{multicols}


\noindent \begin{tabularx}{\columnwidth}{lllllX} 
\textbf{Parameter} & \textbf{Type} & \textbf{Dim} & \textbf{Unit/Format} & \textbf{Optional} & \textbf{Description} \\ \hline 
\inlvar{version} & \inltab{String} & 1 & 0.1 & no & Version of the file format \\ \hline
\inlvar{uuid} & \inltab{String} & 1 & f81d4fae-7dec-11d0-a765-00a0c91e6bf6 & no & Universally Unique Identifier (RFC 4122) \\ \hline 
\inlvar{time} & \inltab{String} & 1 & yyyy-mm-ddThh:mm:ss.ms & no & UTC creation time of MDF data set \\ \hline
\end{tabularx}


\subsection{Study Description (group: \inl{/study/})}

\begin{multicols}{2}

\paragraph{Remarks:} The study description group describes the experimental setting under which the MPI data was recorded. The study field may be used as a name tag for several experiments, which are related. The dataset at hand may then be described by a number and a short description. Additionally, the name of the imaged subject can be provided and the starting time of the MPI measurement can be provided.

The reference field may be used to indicate, if the background signal of the scanner was recorded.

\end{multicols}


\noindent \begin{tabularx}{\columnwidth}{lllllX} 
\textbf{Parameter} & \textbf{Type} & \textbf{Dim} & \textbf{Unit/Format} & \textbf{Optional} & \textbf{Description} \\ \hline 
\inlvar{name} & \inltab{String} & 1 & & yes & Name of the study \\ \hline
\inlvar{experiment} & \inltab{Int64} & 1 & & yes & Experiment number within study \\ \hline
\inlvar{description} & \inltab{String} & 1 & & yes & Short description of the experiment \\ \hline
\inlvar{subject} & \inltab{String} & 1 & & yes & Name of the subject that was imaged \\ \hline 
\inlvar{isSimulation} & \inltab{Int64} & 1 & & yes & Flag indicating if the data in this file is simulated rather than measured \\ \hline
\inlvar{isCalibration} & \inltab{Int64} & $1$ & & no & Flag indicating if data belongs to a system matrix calibration measurement\\ \hline
\end{tabularx}


\subsection{Tracer Parameters (group: \inl{/tracer/})}

\begin{multicols}{2}

\paragraph{Remarks:} The tracer parameter group contains information about the MPI tracer used during the experiment such as the tracer name, its vendor, the tracer concentration, and the total volume applied.

Note that the injection clock recording the injection time should be synchronized with the clock, which provides the starting time of the measurement.

\end{multicols}


\noindent \begin{tabularx}{\columnwidth}{lllllX} 
\textbf{Parameter} & \textbf{Type} & \textbf{Dim} & \textbf{Unit/Format} & \textbf{Optional} & \textbf{Description} \\ \hline 
\inlvar{name} & \inltab{String} & 1 & & yes & Name of tracer used in experiment \\ \hline
\inlvar{batch} & \inltab{String} & 1 & & yes & Batch of tracer \\ \hline
\inlvar{vendor} & \inltab{String} & 1 & & yes & Name of tracer supplier \\ \hline
\inlvar{volume} & \inltab{Float64} & 1 & L & yes & Total volume of applied tracer \\ \hline
\inlvar{concentration} & \inltab{Float64} & 1 & mol(solute)/L & yes & Molar concentration of solute per litre \\ \hline
\inlvar{solute} & \inltab{String} & 1 & & yes & Solute, e.g. Fe \\ \hline
\inlvar{injectionTime} & \inltab{String} & 1 & yyyy-mm-ddThh:mm:ss.ms & yes & UTC time at which tracer injection started \\ \hline
\end{tabularx}

\subsection{Scanner Parameters (group: \inl{/scanner/})}

\begin{multicols}{2}

\paragraph{Remarks:} The scanner parameter group contains information about the MPI scanner used such as the manufacturer, the model, and the facility where the scanner is installed.

\end{multicols}


\noindent \begin{tabularx}{\columnwidth}{lllllX}
\noindent \textbf{Parameter} & \textbf{Type} & \textbf{Dim} & \textbf{Unit/Format} & \textbf{Optional} & \textbf{Description} \\ \hline 
\inlvar{facility} & \inltab{String} & 1 & & yes & Facility where the MPI scanner is installed \\ \hline 
\inlvar{operator} & \inltab{String} & 1 & & yes & User who operates the MPI scanner \\ \hline 
\inlvar{manufacturer} & \inltab{String} & 1 & & yes & Scanner manufacturer \\ \hline 
\inlvar{model} & \inltab{String} & 1 & & yes & Scanner model \\ \hline 
\inlvar{topology} & \inltab{String} & 1 & & no & Scanner topology (e.g. FFP, FFL, MPS)\\ \hline 
\inlvar{boreSize} & \inltab{Float64} & 1 & & yes & Scanner model \\ \hline 
\end{tabularx}

\subsection{Acquisition Parameters (group: \inl{/acquisition/})}

\begin{multicols}{2}

\paragraph{Remarks:} The acquisition parameter group can describe different imaging protocols and trajectory settings. The corresponding data is organized into general information, a subgroup containing data on the particle excitation and a subgroup containing data on the receive channels.

In general each MPI dataset consists of the measurement data of $N$ frames. A frame groups all data together that will be used to reconstruct an image/volume. On certain MPI scanners the drive-field field-of-view (FOV) can be shifted either by magnetic fields or by mechanical movement. Therefore, a frame may consist of $J$ sub-measurements. For instance a Cartesian 2D trajectory with 100 lines would be realized by setting \inl{numPatches} $ = 100$.

The center of the drive-field is specified in the parameter \inl{fieldOfViewCenter}. The shift of the FOV is induced by a certain offset field that can be reported in the parameter \inl{offsetField}

\end{multicols}

\noindent \begin{tabularx}{\columnwidth}{lllllX} 
\textbf{Parameter} & \textbf{Type} & \textbf{Dim} & \textbf{Unit/Format} & \textbf{Optional} & \textbf{Description} \\ \hline 
\inlvar{startTime} & \inltab{String} & 1 & yyyy-mm-ddThh:mm:ss.ms & no & UTC start time of MPI measurement \\ \hline
\inlvar{numFrames} & \inltab{Int64} & 1 & 1 & no & Number of available measurement frames, denoted by $N$ \\ \hline
\inlvar{numBackgroundFrames} & \inltab{Int64} & 1 & 1 & no & Number of available background measurement frames, denoted by $M$ \\ \hline
\inlvar{framePeriod} & \inltab{Float64} & 1 & s & no & Complete time to acquire data of a full frame (product of drive field \inlvar{period}, \inlvar{numPatches}, and \inlvar{numAverages}) \\ \hline
\inlvar{numPatches} & \inltab{Int64} & 1 & 1 & no & Number of patches within a frame denoted by $J$ \\ \hline 
\inlvar{gradient} & \inltab{Float64} & $J \times 3$ & Tm$^{-1}\mu_0^{-1}$ & yes & Gradient strength of the selection field in $x$, $y$, and $z$ directions \\ \hline
\inlvar{offsetField} & \inltab{Float64} & $J \times 3$ & T$\mu_0^{-1}$ & yes & Offset field applied for each patch in the measurement sequence \\ \hline
\inlvar{fieldOfView} & \inltab{Float64} & $J\times 3$ & m & yes & Approximate size of the area/volume captured by the trajectory \\ \hline
\inlvar{fieldOfViewCenter} & \inltab{Float64} & $J \times 3$ & m & yes & Position of the field free point (relative to origin/center) \\ \hline
\end{tabularx}


\subsubsection{Drive Field (group: \inl{/acquisition/drivefield/})}

\begin{multicols}{2}

\paragraph{Remarks:} The drive field subgroup describes the details on the imaging protocol and trajectory settings. On the lowest level each MPI scanner contains $D$ channels for particle excitation. Since most drive-field parameters may change from patch to patch they have a leading $J$ dimension.

These excitation signals are usually sinusoidal and can be described by $D$ amplitudes (drive field strengths), $D$ phases, a base frequency, and $D$ dividers. In a more general setting the drive-field in channel $d$ is described by
$$
H_d(t) = \sum_{l=1}^{F} A_l \Lambda_l (2\pi f_l t + \varphi_l)
$$
where $F$ is the number of frequencies on the channel, $A_l$ is the drive-field strength, $\phi_l$ is the phase, $f_l$ is the frequency (described by the base frequency and the divider), and $\Lambda_l$ is the waveform. The waveform is specified by a dedicated parameter \inl{waveform}. If  \inl{waveform} is set to \textit{custom}, one can specify a custom waveform using the parameter \inl{customWaveform}. The number of sampling points of the \inl{customWaveform} is denoted by $U$. The triangle is defined to be a $2\pi$ periodization of the
triangle function:
$$
 \Lambda_\text{tri}(t) = \left\vert t+\frac{\pi}{2}\right\vert - \frac{\pi}{2} \quad \text{for} \quad -\frac{3}{2}\pi\leq t \leq \frac{\pi}{2}
$$



\end{multicols}


\noindent \begin{tabularx}{\columnwidth}{lllllX} 
\textbf{Parameter} & \textbf{Type} & \textbf{Dim} & \textbf{Unit/Format} & \textbf{Optional} & \textbf{Description} \\ \hline 
\inlvar{numChannels} & \inltab{Int64} & 1 & 1 & no & Number of drive field channels, denoted by $D$ \\ \hline
\inlvar{strength} & \inltab{Float64} & $J \times D \times F $ & T$\mu_0^{-1}$ & no & Applied drive field strength \\ \hline
\inlvar{phase} & \inltab{Float64} & $J \times D \times F$ & T$\mu_0^{-1}$ & no & Applied drive field phase $\varphi$ in radians in the range $[-\pi,\pi)$ \\ \hline
\inlvar{baseFrequency} & \inltab{Float64} & 1 & Hz & no & Base frequency to derive drive field frequencies \\ \hline
\inlvar{customWaveform} & \inltab{Float64} & $D \times F \times U$ & 1 & yes & Custom waveform table \\ \hline
\inlvar{divider} & \inltab{Int64} & $D \times F$ & 1 & no & Divider for drive fields frequencies (\inlvar{baseFrequency} / \inlvar{divider}) \\ \hline
\inlvar{waveform} & \inltab{String} & $D \times F$ & 1 & no & Waveform type: \textit{sine}, \textit{triangle} or \textit{custom} \\ \hline
\inlvar{period} & \inltab{Float64} & 1 & s & no & Drive field trajectory period \\ \hline
\end{tabularx}


\subsubsection{Receiver (group: \inl{/acquisition/receiver/})}

\begin{multicols}{2}

\paragraph{Remarks:} The receiver subgroup describes details on the MPI receiver. For a multi-patch sequence it is assumed, that signal acquisition only takes place during particle excitation. During each drive-field cycle, $C$ receive channels record the superposition of the change of the particle magnetization at $Z$ equidistant time points. The transfer function can optionally be stored in the parameter \inlvar{transferFunction}. It is stored in frequency space representation where $K=\frac{Z}{2}+1$ is the number of discrete frequency components. 

\end{multicols}


\noindent \begin{tabularx}{\columnwidth}{lllllX} 
\textbf{Parameter} & \textbf{Type} & \textbf{Dim} & \textbf{Unit/Format} & \textbf{Optional} & \textbf{Description} \\ \hline 
\inlvar{numChannels} & \inltab{Int64} & 1 & & no & Number of receive channels $C$ \\ \hline 
\inlvar{numAverages} & \inltab{Int64} & 1 & & no & Internal block averaging over a number of drive field cycles \\ \hline 
\inlvar{bandwidth} & \inltab{Float64} & $1$ & Hz & no & Bandwidth of the receiver unit \\ \hline
\inlvar{numSamplingPoints} & \inltab{Int64} & $1$ &  & no & Number of sampling point within one drive-field period denoted by $Z$ \\ \hline
\inlvar{transferFunction} & \inltab{Float64} & $C \times K \times 2$ &  & yes & Transfer function of the receive channel \\ \hline
\end{tabularx}

\subsection{Measurement (group: \inl{/measurement/})}
\begin{multicols}{2}

\paragraph{Remarks:}
MPI data is usually acquired by a series of $N$ measurements and $M$ background measurements. Here we refer to background measurements as MPI data captured, when any signal generating material, e.g. a phantom or a delta sample is removed from the scanner bore. Both the $N$ measurements and the $M$ background measurements can be stored in an arbitrary order, e.g. with respect to the spatial position of a delta sample if the data corresponds to a calibration measurement. To be able to recover the time order in which the measurements were taken each of the $N+M$ data sets can be assigned an integer number $o = 1,2,\dots,N+M$ ordering the measurements and background measurements with respect to time. I.e. data set $o_1$ is acquired prior to data set $o_2$, if and only if $o_1 < o_2$.

The resulting $N$ measurements and $M$ background measurements should be stored in time domain, where the data of a single frame consists of the signal recorded for all patches in each receive channel, i.e. $J \times C \times Z$ data points per set with the temporal index being the fastest to access. If several measurements are acquired (indicated by \textit{numFrames}), the $N$ measurements and $M$ background measurements are concatenated along the slowest dimension respectively.

During measurements the analog signal measured is usually converted into $(r_1,\dots,r_{JZ}) \in \mathbb Z^J \times \mathbb Z^Z$ integer values per channel $c \in C$ and frame using analog to digital converters. Often this raw data is stored instead of the physical quantities they represent. To bring the raw values into a physical representation one can map $r_i \mapsto (a_c r_i + b_c) U$, where $a_c$ and $b_c$ are the characteristic dimensionless scaling factor and offset the receive channel $c \in C$ and $U$ is the corresponding unit of measurement, i.e. usually voltages.

\end{multicols}

\noindent \begin{tabularx}{\columnwidth}{llp{3cm}llX} 
\textbf{Parameter} & \textbf{Type} & \textbf{Dim} & \textbf{Unit/Format} & \textbf{Optional} & \textbf{Description} \\ \hline 
\inlvar{unit} & \inltab{String} & $1$ & & yes & SI unit of the measured quantity, usually V \\ \hline 
\inlvar{rawDataConversion} & \inltab{Number} & $C \times 2$ & & yes & Dimension less scaling factor and offset $(a_c, b_c)$ to convert raw data into a physical quantity with corresponding unit of measurement \inlvar{unit} \\ \hline 
\inlvar{data} & \inltab{Number} & $N \times J \times C \times Z$ & & yes & Measurement data stored in time domain representation \\ \hline 
\inlvar{dataTimeOrder} & \inltab{Int64} & $N$ & & yes & Time ordering number for measurements \\ \hline
\inlvar{backgroundData} & \inltab{Number} &  $M \times J \times C \times Z$ & & yes & Background measurements stored in time domain representation \\ \hline 
\inlvar{backgroundDataTimeOrder} & \inltab{Int64} & $M$ & & yes & Time ordering number for background measurements \\ \hline
\end{tabularx}

\subsection{Calibration (group: \inl{/calibration/})}

\begin{multicols}{2}

\paragraph{Remarks:}
To handle system matrix data efficiently, Fourier transformation and extensive reordering of the raw time domain data is required. Therefore, a post processed and background corrected system matrix can be stored separately. 

This post processing is done as follows:
\begin{itemize}
	\item First, the background corrected time domain data is Fourier transformed along the $Z$ dimension into a $N \times J \times C \times K$ complex valued dataset.
	\item Second, this dataset is brought into a real valued representation of $N \times J \times C \times K \times 2$ real valued data points.
	\item Third, the data is partially transposed into the form $J \times C \times K \times N \times 2$.
\end{itemize}
This representation grants a quick access to the frequency dimensions $J \times C \times K$ and therefore a fast frequency selection without having read the entire system matrix. For this selection often the signal to noise characteristics of the frequency components is used, which can be stored as well, without having to post process the raw measurement data repeatedly. 

Each of the $N$ calibration measurements is taken with a a calibration sample (delta sample) at a fixed position inside the FOV of the scanner. Each background measurement is taken with the delta sample outside of the FOV of the scanner. Usually, the calibration measurements are not stored in the order in which they were taken, but with respect to the corresponding spatial position of the delta sample. If a regular grid of size $N_x \times N_y \times N_z$ is used for sampling, by default the $N_xN_YN_z = N$ measurements are ordered with respect to their $x$ position first, second with respect to their $y$ position and last with respect to their $z$ position. If a different ordering is used this can be documented using the optional parameter \inlvar{order}. For non-regular sampling points there is the possibility to explicitly store all $N$ positions.

\end{multicols}

\noindent \begin{tabularx}{\columnwidth}{llp{3cm}llX} 
\textbf{Parameter} & \textbf{Type} & \textbf{Dim} & \textbf{Unit/Format} & \textbf{Optional} & \textbf{Description} \\ \hline 
\inlvar{systemMatrixData} & \inltab{Number} & $J \times C \times K \times N \times 2$  & & yes & Stores the background corrected system matrix in Fourier representation with the last dimension storing the complex data. \\  \hline
\inlvar{snr} & \inltab{Float64} & $J \times C \times K$ &  & yes & Signal-to-noise estimate for recorded frequency components \\ \hline
\inlvar{fieldOfView} & \inltab{Float64} & $3$ & m & yes & Field of view of system matrix \\ \hline
\inlvar{fieldOfViewCenter} & \inltab{Float64} & $3$ & m & yes & Center of the system matrix (relative to origin/center) \\ \hline
\inlvar{size} & \inltab{Int64} & $3$ &  & yes & Number of voxels in each dimension \\ \hline
\inlvar{order} & \inltab{String} & 1 & & yes & Ordering of the dimensions, default is \textit{xyz} \\ \hline
\inlvar{positions} & \inltab{Float64} & $N \times 3$ & m & yes & Position of each of the grid points, stored as ($x$, $y$, $z$) triples \\ \hline
\inlvar{offsetField} & \inltab{Float64} & $N \times 3$ & T$\mu_0^{-1}$ & yes & Applied offset field strength to emulate a spatial position ($x$, $y$, $z$) \\ \hline
\inlvar{deltaSampleSize} & \inltab{Float64} & 3 & m & yes & Size of delta sample used for calibration scan \\ \hline
\inlvar{method} & \inltab{String} & 1 & & yes & Method used to obtain calibration data. Can for instance be robot, hybrid, or simulation \\ \hline
\end{tabularx}


\subsection{Reconstruction Results (group: \inl{/reconstruction/})}

\begin{multicols}{2}

	Reconstruction results are stored in the parameter \inl{data}. Dependent on the number of individual channels $S$ obtained by the reconstruction the results can be stored in a $L\times P$ array for $S=1$ or in a $L\times P \times S$ array for $S>1$. Since the grid of the reconstruction data can be different than the system matrix grid, the grid parameter are mirrored in the reconstruction parameter group. 

Usually the data is stored in a real data format but it is also possible to store complex data if the reconstruction output is complex.

\end{multicols}

\noindent \begin{tabularx}{\columnwidth}{lllllX} 
\textbf{Parameter} & \textbf{Type} & \textbf{Dim} & \textbf{Unit/Format} & \textbf{Optional} & \textbf{Description} \\ \hline 
\inlvar{data} & \inltab{Number} & $L\times P \times S$ & & yes & Reconstructed data \\ \hline
\inlvar{fieldOfView} & \inltab{Float64} & $3$ & m & yes & Field of view of reconstructed data \\ \hline
\inlvar{fieldOfViewCenter} & \inltab{Float64} & $3$ & m & yes & Center of the reconstructed data (relative to origin/center) \\ \hline 
\inlvar{size} & \inltab{Int64} & $3$ &  & yes & Number of voxels in each dimension \\ \hline
\inlvar{order} & \inltab{String} & 1 & & yes & Ordering of the dimensions, default is \textit{xyz} \\ \hline
\inlvar{positions} & \inltab{Float64} & $P \times 3$ & m & yes & Position of each of the grid points, stored as ($x$, $y$, $z$) tripels \\ \hline
\end{tabularx}


\clearpage
\subsection{Changelog}

\begin{multicols}{2}

\subsubsection{v2.0}

\begin{itemize}
	\item Updated Affiliations in the MDF specification.
	\item Improved the description of various fields. 
	\item Added definition for triangle function.
	\item Infrastructure for storing background data directly with MDF data has been added for both regular measurements and calibration measurements.
	\item In v1.x the MDF allowed certain fields to have varying dimensions depending on the context. This has been removed such that starting from v2.0 all dimensions have to be specified. This change  should make implementations handling MDF files less complex. 
	\item Support for multiple excitation frequencies on a drive-field channel has been added. Additionally we added support for fully arbitrary excitation waveforms.
	\item Added the possibility store the tracer concentration also for non iron based tracer materials by adding the \inlvar{solute} field to the \inlvar{tracer} group.
	\item Specified supported data types for the storage of measurement data and reconstruction data.
	\item Raw data is now always stored in time domain representation for both measurement data and background measurements.
	\item Added possibility to store the transformation from raw data to a physical representation with units.
	\item Signal to noise ratios can now be stored for each patch indivisually. To do so the dimension $J$ was added to this field.
	\item Restructured storage of raw measurement data.
	\item Made fields \inlvar{gradient}, \inlvar{fieldOfView} and \inlvar{fieldOfViewCenter} optional.
	\item Introduced the field \inlvar{dataTimeOrder} and \inlvar{backgroundDataTimeOrder} to store the order in which measurements and background measurements were taken.
	\item Added field \inlvar{numBackgroundFrames} to \inlvar{aquisition} group.
	\item Added field \inlvar{isCalibration} to \inlvar{study} group to indicate if data corresponds to a calibration measurement or not
	\item Moved \inlvar{numAverages} field to \inlvar{receiver} subgroup, \inlvar{offsetfield} field to \inlvar{acquisition} group and \inlvar{fieldOfViewCenter} field to \inlvar{acquisition} group.
	\item Remove \inlvar{/study/reference} since this functionality is now covered by the integrated background measurements.
	\item Rename \inlvar{/study/simulation} to \inlvar{/study/isSimulation} for consistency reasons.
	\item Remove \inlvar{/acquisition/receiver/frequencies} since it can be directly derived from \inlvar{/acquisition/receiver/bandwidth} and \inlvar{/acquisition/receiver/numSamplingPoints}.
	\item Rename \inlvar{/date} to \inlvar{/time} for consistency reasons.
	\item Rename \inlvar{/acquisition/time} to \inlvar{/acquisition/startTime}.
	\item Rename \inlvar{/tracer/time} to \inlvar{/tracer/injectionTime}.
	\item Changed \inlvar{/study/experiment} from \inlvar{String} to \inlvar{Int64}.
\end{itemize}


\subsubsection{v1.0.5}

\begin{itemize}
	\item Added the possibility to store different channels of reconstructed data.
	\item Added support for receive channels with different characteristics (e.g. bandwidth).
	\item Made dataset \inlvar{/acquisition/receiver/frequencies} optional.
	\item Extended the description on the data types, which are used to store data.
	\item Added references for Julia and HDF5 to the specifications.
\end{itemize}


\subsubsection{v1.0.4}

\begin{itemize}
	\item Clarify that HDF5 datasets are used to store MPI parameters.
\end{itemize}


\subsubsection{v1.0.3}

\begin{itemize}
	\item Updated Affiliations in the MDF specification.
	\item Included data download into the Python and Matlab example code.
	\item Changes in the Python and Matlab example code to be better comparable to the Julia example code.
\end{itemize}


\subsubsection{v1.0.2}

\begin{itemize}
	\item Added reference to arXiv paper and bibtex file for reference.
\end{itemize}


\subsubsection{v1.0.1}

\begin{itemize}
	\item A sanity check within the Julia code shipped alongside the specifications.
	\item An update to the specification documenting the availability of a sanity check.
	\item Updated MDF files on https://www.tuhh.de/ibi/research/mpi-data-format.html.
	\item Updated documentation to the Julia, Matlab and Python reconstruction scripts.
	\item Improved Julia reconstruction script, automatically downloading the required MDF files.
\end{itemize}

\end{multicols}


\bibliographystyle{unsrt}
\bibliography{MDF}

\end{document}
